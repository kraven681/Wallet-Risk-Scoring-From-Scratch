# -*- coding: utf-8 -*-
"""Wallet Risk Scoring From Scratch.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uUHz-tQ1CsziS-YkH6336Jp_g4lXEBva
"""

import numpy as np
import pandas as pd
import matplotlib as plt
import seaborn as ans

df = pd.read_csv('/content/Wallet Risk Scoring From Scratch .csv')

df.head()

df.info()

df.describe()

df.dtypes

df.columns

df.isnull().sum()

import requests
import pandas as pd
import time

# Load wallet IDs (replace with your list if needed)
wallets = [
    "0x0039f22efb07a647557c7c5d17854cfd6d489ef3",
    "0x06b51c6882b27cb05e712185531c1f74996dd988",
    # Add the remaining wallets (up to 100)
]

# GraphQL endpoint for Compound V2
url = "https://api.thegraph.com/subgraphs/name/graphprotocol/compound-v2"

# Function to fetch account data from the subgraph
def fetch_wallet_data(wallet):
    query = """
    {
      account(id: "%s") {
        id
        tokens {
          symbol
          supplyBalanceUnderlying
          borrowBalanceUnderlying
        }
        countLiquidated
        countLiquidator
      }
    }
    """ % wallet.lower()

    response = requests.post(url, json={'query': query})
    if response.status_code != 200:
        print(f"Failed for {wallet}")
        return None

    data = response.json().get("data", {}).get("account")
    if not data:
        return {
            "wallet_id": wallet,
            "total_supplied": 0,
            "total_borrowed": 0,
            "num_liquidations": 0,
            "num_times_liquidator": 0
        }

    total_supplied = 0
    total_borrowed = 0
    for token in data["tokens"]:
        total_supplied += float(token.get("supplyBalanceUnderlying", 0))
        total_borrowed += float(token.get("borrowBalanceUnderlying", 0))

    return {
        "wallet_id": wallet,
        "total_supplied": total_supplied,
        "total_borrowed": total_borrowed,
        "net_position": total_supplied - total_borrowed,
        "num_liquidations": int(data.get("countLiquidated", 0)),
        "num_times_liquidator": int(data.get("countLiquidator", 0))
    }

# Process all wallets
results = []
for i, wallet in enumerate(wallets):
    print(f"Fetching {i+1}/{len(wallets)}: {wallet}")
    res = fetch_wallet_data(wallet)
    if res:
        results.append(res)
    time.sleep(0.5)  # Be polite to the API (rate limiting)

# Save as DataFrame
df = pd.DataFrame(results)
df.to_csv("compound_wallet_features.csv", index=False)
print("Saved: compound_wallet_features.csv")

import pandas as pd
import requests
import time

# ✅ Load your wallet list
wallets = pd.read_csv("/content/Wallet Risk Scoring From Scratch .csv")["wallet_id"].dropna().unique().tolist()

# ✅ Compound V2 Subgraph endpoint
SUBGRAPH_URL = "https://api.thegraph.com/subgraphs/name/graphprotocol/compound-v2"

# ✅ Function to fetch wallet features
def fetch_compound_features(wallet):
    query = f"""
    {{
      account(id: "{wallet.lower()}") {{
        id
        tokens {{
          symbol
          supplyBalanceUnderlying
          borrowBalanceUnderlying
        }}
        countLiquidated
        countLiquidator
      }}
    }}
    """
    try:
        res = requests.post(SUBGRAPH_URL, json={"query": query})
        res.raise_for_status()
        data = res.json()["data"]["account"]
        if data is None:
            return {
                "wallet_id": wallet,
                "total_supplied": 0,
                "total_borrowed": 0,
                "net_position": 0,
                "num_liquidations": 0,
                "num_times_liquidator": 0,
            }

        supplied = sum(float(t.get("supplyBalanceUnderlying", 0)) for t in data.get("tokens", []))
        borrowed = sum(float(t.get("borrowBalanceUnderlying", 0)) for t in data.get("tokens", []))
        return {
            "wallet_id": wallet,
            "total_supplied": supplied,
            "total_borrowed": borrowed,
            "net_position": supplied - borrowed,
            "num_liquidations": int(data.get("countLiquidated", 0)),
            "num_times_liquidator": int(data.get("countLiquidator", 0)),
        }
    except Exception as e:
        print(f"Failed for {wallet[:10]}...: {str(e)}")
        return None

# ✅ Loop through all wallets
features = []
for i, wallet in enumerate(wallets):
    print(f"[{i+1}/{len(wallets)}] Processing {wallet}")
    data = fetch_compound_features(wallet)
    if data:
        features.append(data)
    time.sleep(0.4)  # be kind to the API

# ✅ Save the results
df = pd.DataFrame(features)
df.to_csv("compound_wallet_features.csv", index=False)
print("Saved to compound_wallet_features.csv")

import requests
import json

# Set the GraphQL endpoint for Compound V2
url = "https://api.thegraph.com/subgraphs/name/graphprotocol/compound-v2"

# Wallet address
wallet = "0xfaa0768bde629806739c3a4620656c5d26f44ef2"

# Construct the GraphQL query
query = """
{
  account(id: "%s") {
    id
    tokens {
      symbol
      supplyBalanceUnderlying
      borrowBalanceUnderlying
    }
    countLiquidated
    countLiquidator
  }
}
""" % wallet.lower()

# Send POST request
response = requests.post(url, json={'query': query})

# Check response
if response.status_code == 200:
    data = response.json()

    # Check for GraphQL errors
    if "errors" in data:
        print("GraphQL error:", data["errors"])
    elif data.get("data", {}).get("account") is None:
        print(f"No account data found for wallet: {wallet}")
    else:
        print(json.dumps(data["data"]["account"], indent=2))
else:
    print("Query failed with status code", response.status_code)

for i, row in df.iterrows():
    total_supplied = row["total_supplied"]
    total_borrowed = row["total_borrowed"]
    net_position = row["net_position"]
    num_liquidations = row["num_liquidations"]
    num_times_liquidator = row["num_times_liquidator"]

    # Calculate utilization rate
    utilization_rate = total_borrowed / total_supplied if total_supplied > 0 else 0

    # Scoring
    score = 1000

    if utilization_rate > 0.8:
        score -= 300

    score -= 200 * num_liquidations

    if net_position < 0:
        score -= 100

    score += 100 * num_times_liquidator

    # Clamp score between 0 and 1000
    score = max(0, min(1000, score))

    # Assign to DataFrame
    df.loc[i, "score"] = score

print(df.columns)

{
  "id": "0xfaa076...",
  "tokens": [
    {
      "symbol": "cUSDC",
      "supplyBalanceUnderlying": "54.13",
      "borrowBalanceUnderlying": "0.00"
    }
  ],
  "countLiquidated": 0,
  "countLiquidator": 1
}

print(f"{wallet}: {data}")

score = 1000  # Assume low risk if wallet has no activity

print(response.text)

time.sleep(1)

for i, row in df.iterrows():
    score = 1000
    ...
    row["score"] = score  # ❌ This doesn’t update the dataframe

df.loc[i, "score"] = score

import pandas as pd
import requests
import time
from tqdm import tqdm

url = "https://api.thegraph.com/subgraphs/name/graphprotocol/compound-v2"

# Read wallet list
wallets = pd.read_csv("/content/Wallet Risk Scoring From Scratch .csv")
wallets.columns = wallets.columns.str.strip()  # Clean column names
results = []

def fetch_wallet_data(wallet):
    query = """
    {
      account(id: "%s") {
        id
        tokens {
          symbol
          supplyBalanceUnderlying
          borrowBalanceUnderlying
        }
        countLiquidated
        countLiquidator
      }
    }
    """ % wallet.lower()

    response = requests.post(url, json={"query": query})
    if response.status_code != 200:
        print(f"Failed request for {wallet}: {response.status_code}")
        return None

    data = response.json()
    if "errors" in data or data.get("data", {}).get("account") is None:
        print(f"No account data for {wallet}")
        return None

    return data["data"]["account"]

def compute_score(wallet_data):
    total_supplied = 0
    total_borrowed = 0
    tokens = wallet_data.get("tokens", [])

    for token in tokens:
        total_supplied += float(token.get("supplyBalanceUnderlying", 0))
        total_borrowed += float(token.get("borrowBalanceUnderlying", 0))

    net_position = total_supplied - total_borrowed
    utilization_rate = total_borrowed / total_supplied if total_supplied > 0 else 0
    num_liquidations = int(wallet_data.get("countLiquidated", 0))
    num_times_liquidator = int(wallet_data.get("countLiquidator", 0))

    # Scoring logic
    score = 1000
    if utilization_rate > 0.8:
        score -= 300
    score -= 200 * num_liquidations
    if net_position < 0:
        score -= 100
    score += 100 * num_times_liquidator
    score = max(0, min(1000, score))  # Clamp

    return score

# Process wallets
for wallet in tqdm(wallets['wallet_id']):
    try:
        data = fetch_wallet_data(wallet)
        if data is None:
            score = 500  # Neutral if no data
        else:
            score = compute_score(data)
        print(f"{wallet}: {score}")
        results.append({'wallet_id': wallet, 'score': score})
        time.sleep(1)  # Slower to avoid rate limits
    except Exception as e:
        print(f"Error processing {wallet}: {e}")
        results.append({'wallet_id': wallet, 'score': 0})

df_scores = pd.DataFrame(results)
df_scores.to_csv("wallet_risk_scores.csv", index=False)
print("✅ Done: Scores saved to wallet_risk_scores.csv")